// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: kubernetes
:page-layout: guide
:page-duration: 30 minutes
// :page-releasedate: 2018-03-16
:page-description: Explore how to deploy microservices to Kubernetes using Helm charts, setup an Ingress, and automatically rollout updates.
:page-tags: ['microservices']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Deploying microservices to Kubernetes

Explore how to deploy microservices to Kubernetes using Helm charts, setup an Ingress, and automatically rollout updates.

:minikube-ip: 192.168.99.100


== What you'll learn

You will learn how to deploy two microservices to a local Kubernetes cluster using Helm charts. This
will include building and containerizing the microservices, running the containers inside Kubernetes pods,
setting up an ingress to load balance traffic and persists sessions, establishing communicating
between the microservices, scaling deployments, and automatically rolling out new updates when the
microservices are rebuilt.

The two microservices you will deploy are called `name` and `ping` and are provided for you under the
`start/src` directory. The `name` microservice simply displays a brief greeting and the name of the
container that it runs in. This makes it easy to distinguish one running instance of this microservices
from another when its containerized and replicated. The `ping` microservice simply "pings" the Kubernetes
service that encapsulates the pods running the `name` microservice. This demonstrates how communication
between microservices can be established inside of a cluster.

You will use Minikube as your local Kubernetes cluster and the Helm package manager for Kubernetes to
deploy the two microservices. You will also use NGINX as your ingress controller, which you will enable
as an optional addon in Minikube.


// =================================================================================================
// What is Kubernetes
// =================================================================================================

== What is Kubernetes?

Kubernetes is an open-source container orchestrator that automates many tasks involved in deploying,
managing, and scaling containerized applications.

=== Architecture

A typical Kubernetes cluster is a collection of physical or virtual machines called `nodes`. A
cluster is made up of one master `node`, which manages the cluster, and multiple worker `nodes`,
which run the actual application instances inside Kuberntes objects called `pods`.

A `Pod` is a basic building block in a Kubernets cluster. It represents a single running process which
encapsulates an application container or in some scenarios multiple closely-coupled containers. `Pods`
can be replicated to scale applications and handle more traffic. A single `pod` or a group of replicated
`pods` are managed by Kubernetes objects called `controllers`. A `controller` handles replication,
self-healing, rollout of updates, and general management of `pods`. Some examples of `controllers`
are: `Deployment`, `StatefulSet`, and `DaemonSet`. In this guide, you will work with `deployments`.

A `pod` or a group of replicated `pods` are further grouped inside Kubernetes objects called `services`,
which define a set of rules by which the `pods` can be accessed. In a basic scenario, a Kubernetes
`service` will expose a node port, which can be used together with the cluster IP address to access
the `pods` encapsulated by the `service`. In this guide however, you will set up an `ingress`, which is
a Kubernetes object that maps external requests to the services in a cluster, as well as provides
additional functionality.

=== Why use Kubernetes?




// =================================================================================================
// Prerequisites
// =================================================================================================

Before you begin, make sure have the following tools installed:

- `kubernetes-cli` - a command line interface for Kubernetes called `kubectl`. This is your primary
tool for communicating with and managing your Kubernetes cluster.
- `kubernetes-helm` - a package manager for Kubernetes called Helm. Helm allows you to install packages
or "charts", which are sets of preconfigured Kubernetes resources. Installing charts is much more
convenient as they can provide a lot of preconfigured functionality out of the box that normally needs
to be created manually.
- `minikube` - a local virtual machine that runs a single node Kubernetes cluster.

Finally, you will need a containerization software for building containers. Kubernetes supports a variety
of container types and while you're not limited to any of them in particular, this guide will focus
around Docker.

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// no "try what you'll build" section in this guide since it would be too long due to all setup the user will have to do.


// =================================================================================================
// Staring and preparing your cluster for deployment
// =================================================================================================

== Starting and preparing your cluster for deployment

To begin working with your Minikube cluster run the following command from the command line:

```
minikube start
```

This command will setup and start your cluster. Minikube will also configure the cluster so it will
be ready to run out of the box. When you need to stop your cluster, run `minikube stop`.

Next, run the following command to initialize Helm to begin installing charts:

```
helm init
```

This command installs `Tiller` into your cluster which manages installations of your charts.

Next, add the IBM Helm chart repository:

```
helm repo add ibm-charts https://raw.githubusercontent.com/IBM/charts/master/repo/stable/
```

This will give you access to a variety of IBM charts, including the Open Liberty chart, which you
will use to run the `name` and `ping` microservices.

Finally, run the following command to configure the Docker CLI to use the Minikube Docker daemon.
By doing this, you will be able to build Docker images directly to Minikube from your host machine:

```
eval $(minikube docker-env)
```

When you no longer wish to use the Minikube Docker daemon, run `eval $(minikube docker-env -u)` to
point back to your host.


// =================================================================================================
// Building and containerizing the microservices
// =================================================================================================

== Building and containerizing the microservices

The first step of deploying to Kubernetes is to build your microservices and containerize them with Docker.

The Java project located under the `start` directory is a multi-module Maven project thats made up of the `name`
and `ping` microservices, each residing under their respective directories. Each of these directories
contains a Dockerfile, which is picked up by the `dockerfile-maven` plugin defined in the parent
POM. Hence, building the microservices and the Docker images can be done simultaneously through Maven.
To do this, run the Maven `package` goal from the command line:

```
mvn package
```

The `package` goal will automatically invoke the `dockerfile-maven:build` goal which pickups the Dockerfile
located in the same directory as the POM and creates a Docker image from it.
In the output returned by Maven, you see various Docker messages and the images being built. When
the build is finished, run `docker images` from the command line to verify that `name:1.0-SNAPSHOT`
and `ping:1.0-SNAPSHOT` have been successfully built. Be sure that these images have also built to
Minikube rather than your local Docker cache:

[source, role="no_copy"]
----
REPOSITORY                                                       TAG
ping                                                             1.0-SNAPSHOT
name                                                             1.0-SNAPSHOT
open-liberty                                                     latest
gcr.io/kubernetes-helm/tiller                                    v2.9.0
k8s.gcr.io/kube-proxy-amd64                                      v1.10.0
k8s.gcr.io/kube-controller-manager-amd64                         v1.10.0
k8s.gcr.io/kube-apiserver-amd64                                  v1.10.0
k8s.gcr.io/kube-scheduler-amd64                                  v1.10.0
quay.io/kubernetes-ingress-controller/nginx-ingress-controller   0.12.0
k8s.gcr.io/etcd-amd64                                            3.1.12
k8s.gcr.io/kube-addon-manager                                    v8.6
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64                           1.14.8
k8s.gcr.io/k8s-dns-sidecar-amd64                                 1.14.8
k8s.gcr.io/k8s-dns-kube-dns-amd64                                1.14.8
k8s.gcr.io/pause-amd64                                           3.1
k8s.gcr.io/kubernetes-dashboard-amd64                            v1.8.1
k8s.gcr.io/kube-addon-manager                                    v6.5
gcr.io/k8s-minikube/storage-provisioner                          v1.8.0
gcr.io/k8s-minikube/storage-provisioner                          v1.8.1
k8s.gcr.io/defaultbackend                                        1.4
k8s.gcr.io/k8s-dns-sidecar-amd64                                 1.14.4
k8s.gcr.io/k8s-dns-kube-dns-amd64                                1.14.4
k8s.gcr.io/k8s-dns-dnsmasq-nanny-amd64                           1.14.4
k8s.gcr.io/etcd-amd64                                            3.0.17
k8s.gcr.io/pause-amd64                                           3.0
----


// =================================================================================================
// Installing a Helm chart release
// =================================================================================================

== Installing a Helm chart release



```
helm install --name ol-name --set image.pullPolicy=IfNotPresent --set image.repository=name --set image.tag=1.0-SNAPSHOT --set ingress.enabled=true --set ingress.secureBackends=false --set ingress.rewriteTarget=/api/name --set ingress.path=/name --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug
```

```
helm install --name ol-ping --set image.pullPolicy=IfNotPresent --set image.repository=ping --set image.tag=1.0-SNAPSHOT --set ingress.enabled=true --set ingress.secureBackends=false --set ingress.rewriteTarget=/api/ping --set ingress.path=/ping --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug
```

Let's break down the parameters:

[cols="15, 100", options="header"]
|===
| *Argument* | *Description*
| --name |
|===

for a complete breakdown, visit https://github.ibm.com/IBMPrivateCloud/charts/tree/master/stable/ibm-open-liberty

// =================================================================================================
// Scaling
// =================================================================================================

== Scaling

```
kubectl scale deployment ol-name-ibm-open-liberty --replicas=3
```

// =================================================================================================
// Setting up an Ingress
// =================================================================================================

== Setting up an Ingress

```
minikube addons enable ingress
```

// =================================================================================================
// Rolling out updates
// =================================================================================================

== Rolling out updates

```
kubectl set image deployment/ol-name-ibm-open-liberty ibm-open-liberty=name:1.0-SNAPSHOT --record
```

=== Automating with Maven


To build:

1. Install minikube, docker, kubernetes-cli, kubernetes-helm, some VM software like VirtualBox
2. Run `minikube start`
3. Run `helm init`
4. Run `helm repo add ibm-charts https://raw.githubusercontent.com/IBM/charts/master/repo/stable/`
5. Start the Docker daemon and run `eval $(minikube docker-env)`
6. Navigate to `finish` and run `mvn package`
7. Run `docker images` and verify that `name:1.0-SNAPSHOT` and `ping:1.0-SNAPSHOT` have been created.
8. Run `minikube addons enable ingress`
9. Run `helm search ibm` and make sure that `ibm-charts/ibm-open-liberty` is in the list.
10. Run `helm install --name ol-name --set image.pullPolicy=IfNotPresent --set image.repository=name --set image.tag=1.0-SNAPSHOT --set replicaCount=3 --set ingress.enabled=true --set ingress.secureBackends=false --set ingress.rewriteTarget=/api --set ingress.path=/name --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug` and
run `helm install --name ol-ping --set image.pullPolicy=IfNotPresent --set image.repository=ping --set image.tag=1.0-SNAPSHOT --set replicaCount=1 --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug`
11. Run `minikube dashboard`, navigate to `Ingresses`, select your ingress, click `Edit` near the top and add:
```
path: /ping
    etc. (follow same pattern as name but for ping)
```
Alternatively, use `kubectl edit ingress <ingress-name>`
12. Wait until all pods are running.
13. Run `minikube ip` to get the id address of minikube
14. Run `curl -k https://<minikube-ip>/name/name` repeatedly to see different container names displayed.
15. Run `curl -k https://<minikube-ip>/ping/ping/<name-service-name>` to ping the `name` pods.


// Include this section if appropriate
== Running the tests

// Include this for info on how to run the tests
include::{common-includes}/mvnverify.adoc[]

// Including a listing block with test results here

// OPTIONAL: after listing the test results, mention a simple change a user can make/introduce that
// will cause the tests to fail. Be brief and don't give the users all of the instructions. At this
// point, they should be comfortable enough to figure it out on their own.


== Great work! You're done!

// Briefly summarize what the user achieved in this guide (1-2 sentences).

// OPTIONAL: briefly state what the user could do next now that they've learned the technologies in this guide.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
