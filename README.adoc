// INSTRUCTION: Please remove all comments that start INSTRUCTION prior to commit. Most comments should be removed, although not the copyright.
// INSTRUCTION: The copyright statement must appear at the top of the file
//
// Copyright (c) 2017 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: kubernetes
:page-layout: guide
:page-duration: 30 minutes
// :page-releasedate: 2018-03-16
:page-description: Explore how to deploy, scale, and manage microservices on Kubernetes using Helm charts.
:page-tags: ['microservices']
:page-permalink: /guides/{projectid}
:page-related-guides: ['docker']
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
:source-highlighter: prettify
= Deploying microservices on Kubernetes

Explore how to deploy, scale, and manage microservices on Kubernetes using Helm charts.

:default-minikube-ip: 192.168.99.102

== What you'll learn

You will learn how to deploy two microservices on a local Kubernetes cluster using Helm charts. You will
then scale these microservices, setup an Ingress to load balance traffic and persist HTTPs sessions,
edit resources to accommodate for new microservices, and automatically rollout updates to deployments
using Maven.

The two microservices you will deploy are called `name` and `ping` and are provided for you under the
`start/src` directory. The `name` microservice simply displays a brief greeting and the name of the container
that it runs in. This will make it easy to distinguish one instance of this microservice from another when you
replicate it. The `ping` microservice simply "pings" the Kubernetes service that runs multiple replicas
of the `name` microservice. This will demonstrate how communication between microservices can be established
inside of a cluster.

You will use Minikube as your local Kubernetes cluster and Kubernetes Helm to deploy the `name` and
`ping` microservices using preconfigured Kubernetes packages called charts. You will also use NGINX
as the Ingress controller which comes as an addon in Minikube.


// =================================================================================================
// What is Kubernetes
// =================================================================================================

== What is Kubernetes?

Kubernetes is an open-source container orchestrator that automates many tasks involved in deploying,
managing, and scaling containerized applications.

=== Architecture

A typical Kubernetes setup consists of one or more clusters, each consisting of a collection of physical
or virtual machines called `nodes` that run containerized applications. A simple cluster consists of
a single master `node` that manages the overall cluster and multiple worker `nodes` that run `pods`.
Each worker `node` runs the `kubelet` service which it uses to communicate with the master `node`.

`Pods` are groupings of one or more containers that together make up a single application. You can
think of `pods` as application wrappers. `Pods` are created and managed using `controllers`,
which handle replication, rollout of updates, and "self-healing" of `pods`. `Pods` are further grouped
inside `services`, which define a set of rules by which the `pods` can be accessed.


=== Why use Kubernetes?




// =================================================================================================
// Prerequisites
// =================================================================================================

Before you begin, make sure have the following tools installed:

- `kubernetes-cli` - a command line interface for Kubernetes called `kubectl`. This is your primary
tool for managing your Kubernetes cluster.
- `kubernetes-helm` - a package manager for Kubernetes.
- `minikube` - a local virtual machine that runs a single node Kubernetes cluster.

Finally, you will need a software for building containers.

// =================================================================================================
// Getting Started
// =================================================================================================

include::{common-includes}/gitclone.adoc[]

// Try what you'll build is omitted because it would be too long + it would involve setting up  and
// later tearing down the whole cluster.


// =================================================================================================
// Staring and preparing your cluster for deployment
// =================================================================================================

== Starting and preparing your cluster for deployment

To begin working with your Minikube cluster, first start it by running the following command from
the command line:

```
minikube start
```

When you need to stop your cluster, simply run `minikube stop`.

Next, setup Helm to begin working with Kubernetes packages called charts. To do this, run the following
command:

```
helm init
```

This command initializes Helm on the client side and installs Tiller on the server side (into your cluster),
which is used to manage installations of your charts.

Next, add the IBM Helm chart repository:

```
helm repo add ibm-charts https://raw.githubusercontent.com/IBM/charts/master/repo/stable/
```

Finally, run the following command to configure the Docker CLI to use the Minikube Docker daemon.
By doing this, you will be able to build Docker images directly to Minikube:

```
eval $(minikube docker-env)
```

When you no longer wish to use the Minikube host, run `eval $(minikube docker-env -u)` to resume useing
your local Docker daemon.


// =================================================================================================
// Installing a chart archive
// =================================================================================================

== Installing a chart archive

```
helm install --name ol-name --set image.pullPolicy=IfNotPresent --set replicaCount=1 --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug
```

This will install an empty Open Liberty runtime. To view the stauts of your Pods, run `kubectl get pods`.
Similarly, you can also view their status on the minikube dashboard.

The cluster uses Minikube's IP, so all you need is to get the port number on which your pod is served.
To do this run `kubectl get service` and note the port mapping.

Then hit http://{default-minikube-ip}:<nodePort>


// =================================================================================================
// Editing deployments
// =================================================================================================

== Editing deployments

- Maven build

To build:

1. Install minikube, docker, kubernetes-cli, kubernetes-helm, some VM software like VirtualBox
2. Run `minikube start`
3. Run `helm init`
4. Run `helm repo add ibm-charts https://raw.githubusercontent.com/IBM/charts/master/repo/stable/`
5. Start the Docker daemon and run `eval $(minikube docker-env)`
6. Navigate to `finish` and run `mvn package`
7. Run `docker images` and verify that `name:1.0-SNAPSHOT` and `ping:1.0-SNAPSHOT` have been created.
8. Run `minikube addons enable ingress`
9. Run `helm search ibm` and make sure that `ibm-charts/ibm-open-liberty` is in the list.
10. Run `helm install --name ol-name --set image.pullPolicy=IfNotPresent --set image.repository=name --set image.tag=1.0-SNAPSHOT --set replicaCount=3 --set ingress.enabled=true --set ingress.secureBackends=false --set ingress.rewriteTarget=/api --set ingress.path=/name --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug` and
run `helm install --name ol-ping --set image.pullPolicy=IfNotPresent --set image.repository=ping --set image.tag=1.0-SNAPSHOT --set replicaCount=1 --set ssl.enabled=false --set service.port=9080 --set service.targetPort=9080 ibm-charts/ibm-open-liberty --debug`
11. Run `minikube dashboard`, navigate to `Ingresses`, select your ingress, click `Edit` near the top and add:
```
path: /ping
    etc. (follow same pattern as name but for ping)
```
Alternatively, use `kubectl edit ingress <ingress-name>`
12. Wait until all pods are running.
13. Run `minikube ip` to get the id address of minikube
14. Run `curl -k https://<minikube-ip>/name/name` repeatedly to see different container names displayed.
15. Run `curl -k https://<minikube-ip>/ping/ping/<name-service-name>` to ping the `name` pods.

== What you'll learn
// Write about what the user will learn in a meaningful intro paragraph.
// Follow the intro paragraph with more details of what the user will learn, but still keep it brief compared to the overall guide.

// You'll next add the various sections that are needed for a particular guide.


// Add this getting started section to your guide if it is applicable. Use the following include to pull in the git clone instructions from the guides-common repo.
== Getting started
include::{common-includes}/gitclone.adoc[]

// This is a subsection of the "Getting started" section above. It should briefly walk the user through
// how to setup everything in the "finish" directory and try out the finished version of what
// they will be building.
//=== Try what youâ€™ll build
include::{common-includes}/trywhatyoubuild-intro.adoc[]

// Describe what user expects to see after running the complete version of the application.

include::{common-includes}/trywhatyoubuild-end.adoc[]

// Add this section to your guide if it is applicable.
// Put this section in the appropriate order in your guide.
== Building and running the application

// Use the following include to pull in the Maven build instructions from the guides-common repo.
include::{common-includes}/mvnbuild.adoc[]

// In between here, you should state where you application can be found now that its running (ie. what urls)

// Use the following include to pull in the Liberty start/stop server instructions from the guides-common repo.
include::{common-includes}/mvnpackage.adoc[]


== Section title for this section, starting with a gerund like Creating, Building, etc
// Read the wiki for the general rules of thumb to help you with formatting these next few sections:
// https://github.com/OpenLiberty/guides-common/wiki/Rules-of-thumb-for-formatting

// Start each additional section title with a meaningful gerund such as Creating, Building, Testing, Configuring, or Administering.
// Follow the gerund with a meaningful noun phrase. For example: Creating a JAX-RS application
// Have as many sections and section titles as needed.

// What to add for each section:
// We'll be writing these sections by following a flow similar to technical blog posts or college textbooks so that the user thinks about the content.
// Start each section with a meaningful description about what the user is doing in the section.
// Include code snippets.
// Avoid making all the documentation a series of steps and tasks, bullets, or numbered lists.
// Use tick marks around directories, files, values, class names, method names, and so on.
// Example: `this-is-a-file`, `this/is/a/path`, `thisIsAMethod`.


// Include this section if appropriate
== Running the tests

// Include this for info on how to run the tests
include::{common-includes}/mvnverify.adoc[]

// Including a listing block with test results here

// OPTIONAL: after listing the test results, mention a simple change a user can make/introduce that
// will cause the tests to fail. Be brief and don't give the users all of the instructions. At this
// point, they should be comfortable enough to figure it out on their own.


== Great work! You're done!

// Briefly summarize what the user achieved in this guide (1-2 sentences).

// OPTIONAL: briefly state what the user could do next now that they've learned the technologies in this guide.

// Include the below from the guides-common repo to tell users how they can contribute to the guide
include::{common-includes}/finish.adoc[]

// DO NO CREATE ANYMORE SECTIONS AT THIS POINT
// Related guides will be added in automatically here if you included them in ":page-related-guides"
